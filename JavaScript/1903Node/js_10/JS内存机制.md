# JS内存机制

## 内存管理机制
> 内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动”释放。后者被称为垃圾回收

## 了解内存空间的优点

* 了解浅拷贝与深拷贝有什么不同
* 对闭包、原型有更好的理解
* 对于引用数据类型、初始数据类型有更好的理解

## JS内存模型

> JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。

## 基础数据类型与栈区

> JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问 数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。就类似于乒乓球盒子

![图片](./img/栈区.png)

> 这种乒乓球的存放方式与栈区中存取数据的方式是一样的。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。

## 引用数据类型与堆区

> JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。

* 如何去操作对象
> 在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。 

* 我们的堆区存取数据的方式与书架很类似
> 书虽然也是有序的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的属性(key)是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

![堆](./img/存放.png)

> 可以看到，在上面的图中，我们的变量都存在栈区，但是如果变量所对应的是一个对象或者数组，那么它所保存的其实是他们在堆区中的一个地址的指针。

![堆区](./img/堆区存储.png)

> 那么当我们要访问存在于堆区中的内容的时候，首先需要在栈区中获取到这个对象的地址的引用(保存地址的变量)，然后再从堆内存中取得我们需要的数据。

* 通过上面的对于内存空间的理解，接下来我们可以看看他们对于我们的数据有什么样的影响了

- 首先我们来看看面试中常见到的面试题

![面试](./img/面试.png)

#### demo1 

> 上图中的变量是在栈区保存的，那么当栈区中的数据发生拷贝行为的时候，系统会自动为新的变量开辟一个房间，并赋一个新的值，所以在拷贝后，再修改新的变量不会对原来的变量值造成影响。

- 拷贝前

![k](./img/拷贝前.png)

- 拷贝后，更新前

![k](./img/拷贝后.png)

- 更新后

![k](./img/更新后.png)

#### demo2

> 在demo2中我们发现我们是在拷贝一个对象(引用数据类型)。而引用数据类型的拷贝也会为它新开辟一个变量的栈区内存，但不同的是，这个新的变量只会保存原来引用类型的一个地址指针。当指针相同的时候，尽管他们不是同一个变量，但是更改其中一个，另外一个也会受到影响。
* 栈区
  - 拷贝前

  ![m](./img/引用拷贝前.png)

  - 拷贝后,更新前

  ![m](./img/拷贝后引用.png)

  - 更新后

  ![m](./img/引用更新前.png)

* 堆区
  
  - 更新前

  ![m](./img/堆区更新前.png)

  - 更新后

  ![m](./img/堆区更新前后.png)

