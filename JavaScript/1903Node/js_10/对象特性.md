# 对象的特性

## 封装

> 将对象的所有组成部分组合起来，尽可能地隐藏对象的部分细节，使其受到保护，只提供有限的接口与外部发生联系

* 优点

- 安全，使用时无法看到具体的实现细节，只需要直接调用

- 便于修改的操作

### 封装方法

* 工厂函数

> 将对象创建赋值的过程整个封装成一个函数

```javascript
function person(name,age,says){
    let obj={};
    obj.name=name;
    obj.age=age;
    obj.say=function(){
        alert(says);
    }
    return obj;
}
let newObj = person('陈伟霆'，18，"迷人，性感");
console.log(newObj);
```

* 构造函数(首字母大写一般来表示一个构造函数)

```javascript
function Transport(obj) {
            this.name = obj.name;
            this.price = obj.price;
            this.color = obj.color;
            this.lang = obj.lang;
            this.high = obj.high;
            this.model = obj.model;
            this.run = obj.run;
        }
        Transport.prototype.tyreNum = 4;
        let sObj = { 
            name: "劳斯莱斯幻影", 
            price: "￥1200万", 
            color: "#000", 
            lang: "4m", 
            high: "1.2m", 
            model: "uek_1",
            run: function (){
                console.log("爷的品味你永远不懂!");
            }
        }
        let car = new Transport(sObj);

```

* 工厂函数和构造函数的弊端

> 每次使用工厂函数和构造函数都会将其中的属性和方法放到一个新的内存当中，导致出现一些重复的属性和方法，占用内存

> 为了解决这种弊端，JS为我们提供了构造函数的原型，用来储存共享的属性和方法(原型是构造函数的一个属性prototype,原型本身是一个对象)
***原型是构造函数的一个属性，这个属性的属性名是prototype，这个属性的属性值是对象***

```javascript
 Transport.prototype.tyreNum = 4;
 console.log(car.tyreNum);
```

> 混合函数

>构造函数与prototype结合

>将一些私有的属性和方法放在构造函数中,一些共享的属性和方法放在原型中

## 对象的继承

### 概念

>在js中，在一个对象的基础上创建一个新对象，这个新对象拥有原对象的属性和方法

### 继承优点

> 增加代码的重复利用率

> 增强代码的逻辑型和可维护性

### 实现继承的方式

* 原型继承

> 将父对象的实例放在子对象的原型中,实现继承

```javascript
 function Animal() {
            this.eat = function(food) {
                alert(food);
            }
        }

        function Gorilla(name) {
            this.name = name;
        }
        Gorilla.prototype = new Animal();
        //给父类Anmail的实例作为子对象的原型，实现继承
        let gorilla = new Gorilla();
        gorilla.eat('香蕉');
```

* call继承  call是函数的方法前面的父对象是构造函数

> 使用call来继承父对象的方法，原理是改变子对象的this指向，将子对象的this指向父对象，就可以实现使用父对象的方法。
> 父对象.call(子对象,参数)

```javascript
 function Animal() {
            this.eat = function(food) {
                alert(food);
            }
        }
        function Gorilla(name) {
            this.name = name;
        }
       let animal=new Animal();  //父对象
       let baboon = new Gorilla("狒狒");  //子对象
       //animal.eat.call(baboon,"猴子");继承的父对象的单个方法
       Animal.call(baboon);
       baboon.eat('banana');
```

* apply继承

> 改变子对象的this指向

```javascript
function Animal() {
            this.eat = function(food) {
                alert(food);
            }
        }

        function Gorilla(name) {
            this.name = name;
        }
        let animal=new Animal();  //父对象
        let baboon = new Gorilla("狒狒");  //子对象
        animal.eat.apply(baboon,["小菲菲"]);//继承单个方法
        Animal.apply(baboon);//将对象中的方法全部继承
        baboon.eat('瓜子')
```

* bind继承

>bind与call继承类似，都是改变的this指向，并且参数都是写在子对象后面，用逗号隔开

```javascript
function Animal() {
            this.eat = function(food) {
                alert(food);
            }
        }
        function Gorilla(name) {
            this.name = name;
        }
        let animal=new Animal();  //父对象
        let baboon = new Gorilla("狒狒");  //子对象
        let a=animal.eat.bind(baboon,"冰激凌！");
```

```javascript
function Animal() {
            this.eat = function(food) {  //this指向Animal
                alert(food);
            }
        }

        function Gorilla(name) {
            Animal.call(this);  //
            this.name = name;
        }
        let md=new Gorilla;
        md.eat('猴子');

```

* call,apply,bind的区别

- call和bind中的参数是跟在子对象的后面，用逗号隔开

- apply中的参数是跟在子对象后面，都放在一个数组中
 
- call和apply在使用的时候是一个立即执行函数，但是bind最终返回的是函数本身，留待后面使用

### 继承的顺序

>对象本身=>对象的和构造函数=>原型链

* 原型链
>在访问对象的属性或方法的时候，会先从对象自身开始寻找，如果没有回去这个对象的构造函数寻找，如果也没有就会去构造函数的原型寻找，如果原型没有就会去原型的构造函数寻找，以此类推，直到找到Object，object的原型，null如果没有属性会返回undefined，方法会报错

```javascript
Object.prototype.say = function(){
            alert("我是Object上的say方法");
        }

        function Person(){
            this.say = function (){
                alert("我是Person的say方法")
            }
        }

        Person.prototype.say = function (){
            alert("我是Person原型的say方法");
        }

        let programmer = new Person();
        console.log(programmer);
        programmer.say();
```

